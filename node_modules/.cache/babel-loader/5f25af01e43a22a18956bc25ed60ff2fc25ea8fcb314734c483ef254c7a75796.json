{"ast":null,"code":"// Register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\nconst isLocalhost = () => Boolean(window.location.hostname === 'localhost' ||\n// [::1] is the IPv6 localhost address.\nwindow.location.hostname === '[::1]' ||\n// 127.0.0.1/8 is considered localhost for IPv4.\nwindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\nlet waitWindowLoad;\n// https://github.com/yyx990803/register-service-worker/pull/33#discussion_r394181861\nif (typeof window !== 'undefined') {\n  // Typically, a browser that supports `serviceWorker` should also have supported\n  // `Promise`. But as this package can be used in environments without service\n  // worker support (in that case it would do nothing), there's a chance that\n  // `Promise` does not exist. So we must check for its existence first.\n  if (typeof Promise !== 'undefined') {\n    waitWindowLoad = new Promise(resolve => window.addEventListener('load', resolve));\n  } else {\n    waitWindowLoad = {\n      then: cb => window.addEventListener('load', cb)\n    };\n  }\n}\nexport function register(swUrl, hooks = {}) {\n  const {\n    registrationOptions = {}\n  } = hooks;\n  delete hooks.registrationOptions;\n  const emit = (hook, ...args) => {\n    if (hooks && hooks[hook]) {\n      hooks[hook](...args);\n    }\n  };\n  if ('serviceWorker' in navigator) {\n    waitWindowLoad.then(() => {\n      if (isLocalhost()) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, emit, registrationOptions);\n        navigator.serviceWorker.ready.then(registration => {\n          emit('ready', registration);\n        }).catch(error => handleError(emit, error));\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, emit, registrationOptions);\n        navigator.serviceWorker.ready.then(registration => {\n          emit('ready', registration);\n        }).catch(error => handleError(emit, error));\n      }\n    });\n  }\n}\nfunction handleError(emit, error) {\n  if (!navigator.onLine) {\n    emit('offline');\n  }\n  emit('error', error);\n}\nfunction registerValidSW(swUrl, emit, registrationOptions) {\n  navigator.serviceWorker.register(swUrl, registrationOptions).then(registration => {\n    emit('registered', registration);\n    if (registration.waiting) {\n      emit('updated', registration);\n      return;\n    }\n    registration.onupdatefound = () => {\n      emit('updatefound', registration);\n      const installingWorker = registration.installing;\n      installingWorker.onstatechange = () => {\n        if (installingWorker.state === 'installed') {\n          if (navigator.serviceWorker.controller) {\n            // At this point, the old content will have been purged and\n            // the fresh content will have been added to the cache.\n            // It's the perfect time to display a \"New content is\n            // available; please refresh.\" message in your web app.\n            emit('updated', registration);\n          } else {\n            // At this point, everything has been precached.\n            // It's the perfect time to display a\n            // \"Content is cached for offline use.\" message.\n            emit('cached', registration);\n          }\n        }\n      };\n    };\n  }).catch(error => handleError(emit, error));\n}\nfunction checkValidServiceWorker(swUrl, emit, registrationOptions) {\n  // Check if the service worker can be found.\n  fetch(swUrl).then(response => {\n    // Ensure service worker exists, and that we really are getting a JS file.\n    if (response.status === 404) {\n      // No service worker found.\n      emit('error', new Error(`Service worker not found at ${swUrl}`));\n      unregister();\n    } else if (response.headers.get('content-type').indexOf('javascript') === -1) {\n      emit('error', new Error(`Expected ${swUrl} to have javascript content-type, ` + `but received ${response.headers.get('content-type')}`));\n      unregister();\n    } else {\n      // Service worker found. Proceed as normal.\n      registerValidSW(swUrl, emit, registrationOptions);\n    }\n  }).catch(error => handleError(emit, error));\n}\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    }).catch(error => handleError(emit, error));\n  }\n}\nexport default register();","map":{"version":3,"names":["isLocalhost","Boolean","window","location","hostname","match","waitWindowLoad","Promise","resolve","addEventListener","then","cb","register","swUrl","hooks","registrationOptions","emit","hook","args","navigator","checkValidServiceWorker","serviceWorker","ready","registration","catch","error","handleError","registerValidSW","onLine","waiting","onupdatefound","installingWorker","installing","onstatechange","state","controller","fetch","response","status","Error","unregister","headers","get","indexOf"],"sources":["C:/Users/Navee/OneDrive/Desktop/Web-Py/webdevcourse/ZtmWebdev/React/robofriends/src/registerServiceWorker.js"],"sourcesContent":["// Register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\nconst isLocalhost = () => Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\nlet waitWindowLoad\n// https://github.com/yyx990803/register-service-worker/pull/33#discussion_r394181861\nif (typeof window !== 'undefined') {\n  // Typically, a browser that supports `serviceWorker` should also have supported\n  // `Promise`. But as this package can be used in environments without service\n  // worker support (in that case it would do nothing), there's a chance that\n  // `Promise` does not exist. So we must check for its existence first.\n  if (typeof Promise !== 'undefined') {\n    waitWindowLoad = new Promise(resolve => window.addEventListener('load', resolve))\n  } else {\n    waitWindowLoad = { then: (cb) => window.addEventListener('load', cb) }\n  }\n}\n\nexport function register (swUrl, hooks = {}) {\n  const { registrationOptions = {}} = hooks\n  delete hooks.registrationOptions\n\n  const emit = (hook, ...args) => {\n    if (hooks && hooks[hook]) {\n      hooks[hook](...args)\n    }\n  }\n\n  if ('serviceWorker' in navigator) {\n    waitWindowLoad.then(() => {\n      if (isLocalhost()) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, emit, registrationOptions)\n        navigator.serviceWorker.ready.then(registration => {\n          emit('ready', registration)\n        }).catch(error => handleError(emit, error))\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, emit, registrationOptions)\n        navigator.serviceWorker.ready.then(registration => {\n          emit('ready', registration)\n        }).catch(error => handleError(emit, error))\n      }\n    })\n  }\n}\n\nfunction handleError (emit, error) {\n  if (!navigator.onLine) {\n    emit('offline')\n  }\n  emit('error', error)\n}\n\nfunction registerValidSW (swUrl, emit, registrationOptions) {\n  navigator.serviceWorker\n    .register(swUrl, registrationOptions)\n    .then(registration => {\n      emit('registered', registration)\n      if (registration.waiting) {\n        emit('updated', registration)\n        return\n      }\n      registration.onupdatefound = () => {\n        emit('updatefound', registration)\n        const installingWorker = registration.installing\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              emit('updated', registration)\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              emit('cached', registration)\n            }\n          }\n        }\n      }\n    })\n    .catch(error => handleError(emit, error))\n}\n\nfunction checkValidServiceWorker (swUrl, emit, registrationOptions) {\n  // Check if the service worker can be found.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (response.status === 404) {\n        // No service worker found.\n        emit('error', new Error(`Service worker not found at ${swUrl}`))\n        unregister()\n      } else if (response.headers.get('content-type').indexOf('javascript') === -1) {\n        emit('error', new Error(\n          `Expected ${swUrl} to have javascript content-type, ` +\n          `but received ${response.headers.get('content-type')}`))\n        unregister()\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, emit, registrationOptions)\n      }\n    })\n    .catch(error => handleError(emit, error))\n}\n\nexport function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    }).catch(error => handleError(emit, error))\n  }\n}\n\nexport default register();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}